meta {
  name: ai-usage
  type: http
  seq: 1
}

get {
  url: {{url}}/v1/analytics/ai-usage?filter[aiUsageActions]=CHAT_LINE,CHAT_PROJECT
  body: none
  auth: inherit
}

params:query {
  filter[aiUsageActions]: CHAT_LINE,CHAT_PROJECT
  ~period: day
  ~group[by]: userGroup
  ~group[pagination][page]: 1
  ~group[pagination][perPage]: 2
  ~group[sort]: -totalPrice
  ~filter[startAt]: 2025-09-08T13:04:26.134Z
  ~filter[endAt]: 2025-09-08T13:04:26.134Z
  ~filter[projectIds]: 2025-09-08T13:04:26.134Z
  ~filter[userIds]: 2025-09-08T13:04:26.134Z
  ~filter[userGroupIds]: 019ba1da-874a-70af-8b8b-2783ba7c1c40
}

settings {
  encodeUrl: true
  timeout: 0
}

docs {
  การใช้งาน ai usage api
  
  api นี้จะเป็น api ที่ค่อนค้าง dynamic เพื่อใช้ดูข้อมูลต่างๆของ ai usage schema ของ response จะหน้าตาเหมือนกันแค่บาง key จะเป็น optional
  
  **ทุก param ที่เป็น enum สามารถยิง key ผิดไปและดูตัวเลือกได้จาก error**
  
  ### Response Explain
  
  `chatSummaries`
  เป็น array ของข้อมูลทั้งหมด ภายในแต่ละ object จะแบ่งข้อมูลออกเป็น 3section
  - timestamp
  - summary
  - relations
  
  `timestamp?` (optional)
  จะแสดงก็ต่อเมื่อเปิดใช้งาน period เป็น ISO เพื่อหั่น range ตามที่เลือก
  
  `summary`
  ข้อมูลสรุป data เพื่อใช้ประมวลผล
  - totalPrice: ราคา (USD)
  	- data ที่คืนมาเป็น string ไม่ได้มีการ round decimal place เลยเนื่องจากระบบต้องคำนวนตั้งแต่ทศนิยม 2-10 ค่านี้เลยอาจออกมาเป็น `"100"` หรือ `"100.000000001"` ก็ได้
  - totalTokenUsed: จำนวน token ที่ใช้งาน (round 2decimal)
  - totalChatUsages: จำนวน chat ที่เรียกใช้ (round 2decimal)
  - avgReplyTimeMs: เวลาเฉลี่ยในการ reply (milliseconds) (round 2decimal)
  - avgConfidence: ค่าเฉลี่ยความมั่นใจของ AI (0-100) (round 2decimal)
  - totalAnswerable: การตอบสำเร็จ (จากทั้งหมด totalChatUsages) (round 2decimal)
  
  `relations`
  - key นี้จะแสดงเสมอ แต่ถ้าหากไม่เปิดใช้งาน grouping จะ return มาเป็น object เปล่า `{}`
  - หากเปิดใช้งานจะ ทำงานเหมือน relations ทั่วไป ที่มี entity พร้อมกับ attributes
  
  ### Param Explain
  
  **IMPORTANT**
  api เส้นนี้จะคืน data ทั้งหมดมาแต่ตาม business logic ของหน้า dashboard นี้เขาต้องการแค่ ai usage ของการ chat เท่านั้น Frontend จำเป็นต้องยิง filter นี้มาเสมอทุกหน้า (ณตอนนี้)
  ```
  filter[aiUsageActions]=CHAT_LINE,CHAT_PROJECT
  ```
  
  บาง section ของ param จะเป็นการเปิดใช้งานแต่ละ *feature* ของตัว api ที่จะแสดงผล optional data ของ response schema (ตาม section ด้านบน)
  
  `filter`
  เป็นการ filter ตัวข้อมูลทั้งหมดตามปกติ
  
  `period`
  เปิดใช้งาน *feature* การแบ่ง section ข้อมูลตาม range เวลาและทำให้ response แสดง key `timestamp`
  
  `group`
  เปิดใช้งาน grouping และ ภายในจะมี nested require และ optional filter
  
  `group[by]` (require ถ้าเปิดใช้งาน group)
  ชุดข้อมูลที่อยากทำ grouping ถ้าหากเลือก group แล้วภายใน `relations` จะมี `attributes` ของ group ที่เลือกแสดงขึ้นมา
  
  `group[pagination][page]` `group[pagination][perPage]`
  การ paginate ตัวข้อมูลภายในใช้งานเหมือน paginate ปกติ
  
  `group[sort]`
  การ sort ข้อมูลด้านใน ใช้งานเหมือน sort ปกติ
  
  *period คือ priority*
  ถ้าหากเปิดใช้งาน period การ sort และ shape ของข้อมูลจะ priority period ก่อนเสมอ
  หมายความว่าถ้าเลือกใช้ pagination และเปิด period ข้อมูลที่คืนมาอาจไม่ตรงกับ per page เพราะเรราทำการ pagination ข้อมูลข้างใน 
  
  หากเลือก period day พร้อม pagination และ groupby project
  จะเป็นการ limit ว่า project ภายใน range วันนั้นมีได้มากสุดแค่สอง project
  หากมีการ sort ตัวข้อมูลก็จะ sort ตาม range วันก่อนและ sort ข้อมูลภายในวันอีกที
  
}
